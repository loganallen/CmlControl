open Utils\nopen Print\nopen Unix\n\ntype command =\n| Add | Branch | Checkout | Commit | Diff | Help | Init | Log\n| Merge | Reset | Rm | Stash | Status | User\n\ntype input = { cmd: command; args: string list }\n\nexception Parsing of string\n\nlet perm = 0o777\n\n(* add file contents to the index *)\nlet add (args: string list) : unit =\n  try\n  (* if List.hd args = "." or "-A" then\n  run on all files that are changed. use diff? else *)\n  List.iter (fun file_name ->\n  if not (Sys.file_exists file_name) then\n  raise (Fatal "That file does not exist.")\n  else let hash = (create_blob file_name) in\n  let idx = get_index () in\n  update_index idx (file_name,hash) |> set_index ) args;\n  with\n  | Failure f -> print ("Fatal: add must accept files")\n  | Fatal msg -> print ("Fatal: " ^msg)\n\n\n(* list, create, or delete branches *)\nlet branch (args: string list) : unit =\n  match args with\n  | [] -> begin\n    let cur = get_current_branch () in\n    let branch_print b =\n      if b = cur then (print_string "* "; print_color cur "g")\n      else print ("  "^b)\n    in\n    get_branches () |> List.iter branch_print\n  end\n  | b::[] -> begin\n    if b = "-d" || b = "-D" then raise (Fatal "branch name required")\n    else create_branch b\n  end\n  | flag::b::_ -> begin\n    if flag = "-d" || flag = "-D" then delete_branch b\n    else raise (Fatal "invalid flags, see [--help]")\n  end\n\n(* switch branches or restore working tree files *)\nlet checkout (args: string list) : unit =\n  match args with\n  | []    -> raise (Fatal "branch name or HEAD version required")\n  | h::[] -> begin\n    if h = "-b" || h = "-B" then\n      raise (Fatal "branch name required")\n    else\n      begin\n        if (get_branches () |> List.mem h) then\n          switch_branch h\n        else if (get_versions () |> List.mem h) then\n          switch_version h\n        else\n          raise (Fatal ("pathspec \'"^h^"\' does not match an file(s) know to cml"))\n      end\n  end\n  | flag::b::_ -> begin\n    if flag = "-b" || flag = "-B" then\n      let _ = create_branch b in switch_branch b\n    else\n      raise (Fatal ("invalid flags, see [--help]"))\n  end\n\n(* record changes to the repository:\n * stores the current contents of the index in a new commit\n * along with commit metadata. *)\nlet commit (args: string list) : unit =\n  failwith "Unimplemented"\n\n(* show changes between working tree and previous commits *)\nlet diff (args: string list) : unit =\n  failwith "Unimplemented"\n\n(* display help information about CmlControl. *)\nlet help () : unit =\n  print_help ()\n\n(* init Create an empty CmlControl repository. *)\nlet init () : unit =\n  if cml_initialized "./" then\n    raise (Fatal "Cml repository already initialized")\n  else\n    mkdir ".cml" perm; mkdir ".cml/heads" perm; mkdir ".cml/objects" perm;\n    let _ = create_branch "master" in\n\t\tlet out = open_out ".cml/HEAD" in\n\t\toutput_string out "heads/master"; close_out out;\n    print_color "initialized empty Cml repository" "b"\n\n(* display the current branches commit history *)\nlet log () : unit =\n  failwith "Unimplemented"\n\n(* join two or more development histories together *)\nlet merge (args: string list) : unit =\n  failwith "Unimplemented"\n\n(* reset the current HEAD to a specified state *)\nlet reset (args: string list) : unit =\n  failwith "Unimplemented"\n\n(* remove files from working tree and index *)\nlet rm (args: string list) : unit =\n  failwith "Unimplemented"\n\n(* stashes changes made to the current working tree *)\nlet stash (args: string list) : unit =\n  failwith "Unimplemented"\n\n(* show the working tree status *)\nlet status () : unit =\n    print ("On branch " ^ (get_current_branch ()));\n    let cwd = get_all_files ["./"] [] in\n    let idx = get_index () in\n    let st = get_staged idx in\n    let ch = get_changed cwd idx in\n    let ut = get_untracked cwd idx in\n      match (st,ch,ut) with\n      | [],[],[] -> print "no changes to be committed, working tree clean"\n      | _ -> let _ = print_staged st in\n             let _ = print_changed ch in print_untracked ut\n\n(* set the user info to [username] *)\nlet user (args: string list) : unit =\n  match args with\n  | []   -> let name = get_user_info () in print ("Current user: "^name)\n  | h::_ -> set_user_info h\n\n(* parses bash string input and returns a Cml input type *)\nlet parse_input (args : string array) : input =\n  match (Array.to_list args) with\n  | [] -> raise (Fatal "no command given, see [--help]")\n  | h::t -> begin\n    match h with\n    | "add"      -> {cmd = Add; args = t}\n    | "branch"   -> {cmd = Branch; args = t}\n    | "checkout" -> {cmd = Checkout; args = t}\n    | "commit"   -> {cmd = Commit; args = t}\n    | "diff"     -> {cmd = Diff; args = t}\n    | "init"     -> {cmd = Init; args = t}\n    | "log"      -> {cmd = Log; args = t}\n    | "merge"    -> {cmd = Merge; args = t}\n    | "reset"    -> {cmd = Reset; args = t}\n    | "rm"       -> {cmd = Rm; args = t}\n    | "stash"    -> {cmd = Stash; args = t}\n    | "status"   -> {cmd = Status; args = t}\n    | "--help"   -> {cmd = Help; args = t}\n    | "--user"   -> {cmd = User; args = t}\n    | cmd        -> raise (Parsing cmd)\n  end\n\n(* executes a Cml command *)\nlet execute (i : input) : unit =\n  try\n    if not (i.cmd = Init || i.cmd = Help) && not (cml_initialized "./") then\n      raise (Fatal "Not a Cml repository (or any of the parent directories)")\n    else\n      match i.cmd with\n      | Add      -> add i.args\n      | Branch   -> branch i.args\n      | Checkout -> checkout i.args\n      | Commit   -> commit i.args\n      | Diff     -> diff i.args\n      | Help     -> help ()\n  \t\t| Init     -> init ()\n      | Log      -> log ()\n      | Merge    -> merge i.args\n      | Reset    -> reset i.args\n      | Rm       -> rm i.args\n      | Stash    -> stash i.args\n      | Status   -> status ()\n      | User     -> user i.args\n  with\n  | Fatal msg -> print ("fatal: "^msg)\n